\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{newclude}
\usepackage{float}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{indentfirst}
\usepackage{multirow}
\usepackage{pgfplots}
\usepackage{tikz}
 \usepackage{url}
\usepackage{titlesec}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usepackage{subcaption}

\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{minted}
\usepackage{tabularx}
\lstdefinestyle{mystyle}{
    belowcaptionskip=1\baselineskip,
    frame=single, 
    frameround=tttt,
    xleftmargin=\parindent,
    language=[x86masm]Assembler,
    basicstyle=\footnotesize\ttfamily,
    commentstyle=\itshape\color{green!60!black},
    keywordstyle=\color{blue!80!black},
    identifierstyle=\color{red!80!black},
    tabsize=4,
    numbers=left,
    numbersep=8pt,
    stepnumber=1,
    numberstyle=\tiny\color{gray}, 
    columns = fullflexible,
}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{setspace} % Pakiet do ustawiania interlinii
\onehalfspacing
\begin{document}

\begin{titlepage}
		\begin{figure}[h]
			\begin{minipage}[l]{.5\textwidth}%
				\includegraphics[width=0.3\textwidth]{pwr_logo}
			\end{minipage}%
			\begin{minipage}[r]{.5\textwidth}%
				\includegraphics[width=1\textwidth]{wit_logo}
			\end{minipage}%
		\end{figure}
		
		\vspace*{3mm}
		
		\begin{center}
			\rule{\textwidth}{0.8pt}\\ 
			\vspace*{6mm}
			{\LARGE \textbf{Badania operacyjne i optymalizacja dyskretna}\\
            
            \vspace*{6mm}
            
            Algorytmy znajdowania najkrótszej ścieżki }\\
            \vspace*{3mm}
			\rule{\textwidth}{0.8pt}\\
			
			\vspace{1.5cm}
			{\setstretch{2}
				Politechnika Wrocławska
				
				Wydział Informatyki i Telekomunikacji
				
				Kierunek: Informatyczne Systemy Automatyki
				
				Grupa nr 1
				
				
			}
		\end{center}
		
		\vspace*{2cm}
		
		\begin{flushright}
			{\setstretch{2}
            	Konrad Pempera - $263948$\\
				Dawid Różański - $263524$\\
	
                
				\textbf{Termin zajęć}: Środa godz. $11^{\underline{15}}$ - $13^{\underline{00}}$ 
				
				\textbf{Prowadzący:} Dr inż. Mariusz Makuchowski
				
			}
			
		\end{flushright}
		
		\vfill
		
\end{titlepage}

\tableofcontents
\clearpage
\section{Wstęp}

Celem laboratorium było zaimplementowanie oraz porównanie algorytmów Dijkstry i A* w problemie wyznaczania najkrótszej ścieżki w grafie dwuwymiarowym reprezentującym siatkę.

Problem najkrótszej ścieżki jest jednym z fundamentalnych zagadnień teorii grafów i znajduje szerokie zastosowanie w nawigacji, planowaniu tras, grach komputerowych oraz systemach automatyki. W pracy rozważano konkretne zastosowanie: wyznaczanie najkrótszej ścieżki w dwuwymiarowej siatce z przeszkodami, gdzie każde pole może być wolne, być ścianą (przeszkodą), punktem startowym lub punktem końcowym.

Algorytm Dijkstry jest klasycznym rozwiązaniem problemu najkrótszej ścieżki, które gwarantuje znalezienie optymalnej trasy w grafach z nieujemnymi wagami krawędzi. Algorytm A* stanowi rozszerzenie metody Dijkstry poprzez wprowadzenie funkcji heurystycznej, która kieruje przeszukiwaniem w stronę celu, co często prowadzi do szybszego znalezienia rozwiązania.

W pracy przeprowadzono pomiary czasów wykonania obu algorytmów w zależności od rozmiaru siatki. Uzyskane wyniki umożliwiają ocenę wydajności badanych metod oraz porównanie efektywności podejścia klasycznego (Dijkstra) z podejściem heurystycznym (A*).

\section{Pomiary czasów}
\subsection{Analiza wyników pomiarów czasu wykonania}

Na rysunku \ref{fig:shortest_path_chart} przedstawiono porównanie czasów wykonania algorytmów Dijkstry oraz A* dla siatek o rozmiarach od $100 \times 100$ do $1000 \times 1000$ wierzchołków. Każdy pomiar został uśredniony po 10 powtórzeniach na losowo generowanych instancjach problemu, gdzie około 30\% pól to przeszkody, a pozostałe 70\% to pola wolne.

Z wykresu wynika, że czas wykonania obu algorytmów rośnie wraz ze wzrostem rozmiaru siatki, co jest zgodne z ich teoretyczną złożonością obliczeniową. Dla małych siatek (do około 300 wierzchołków w jednym wymiarze) oba algorytmy wykazują podobną wydajność. Jednak dla większych siatek algorytm A* staje się wyraźnie szybszy od algorytmu Dijkstry.

Dla siatki $1000 \times 1000$ algorytm Dijkstry osiąga czas wykonania około 7,45 sekundy, podczas gdy A* potrzebuje około 5,20 sekundy. Oznacza to, że A* jest o około 30\% szybszy dla dużych instancji problemu. Ta przewaga wynika z zastosowania funkcji heurystycznej (odległość euklidesowa do celu), która kieruje przeszukiwaniem w stronę punktu końcowego, zmniejszając liczbę odwiedzanych wierzchołków.

\subsection{Wnioski}

\begin{itemize}
    \item Czas wykonania obu algorytmów rośnie wraz ze wzrostem rozmiaru siatki, co jest zgodne z ich teoretyczną złożonością obliczeniową.
    \item Algorytm A* jest szybszy od algorytmu Dijkstry, szczególnie dla dużych instancji problemu, co wynika z zastosowania funkcji heurystycznej kierującej przeszukiwaniem.
    \item Dla małych siatek różnica w wydajności między algorytmami jest niewielka, jednak staje się ona istotna dla siatek o rozmiarze powyżej $300 \times 300$ wierzchołków.
    \item Algorytm Dijkstry gwarantuje znalezienie najkrótszej ścieżki bez dodatkowych założeń, podczas gdy A* wymaga dobrej funkcji heurystycznej — w tym przypadku odległość euklidesowa sprawdza się bardzo dobrze.
    \item W zastosowaniach praktycznych, gdzie istotna jest szybkość obliczeń i dostępna jest sensowna heurystyka, algorytm A* jest lepszym wyborem. W przypadku gdy brak jest dobrej heurystyki lub wymagana jest maksymalna prostota implementacji, algorytm Dijkstry pozostaje solidnym rozwiązaniem.
\end{itemize}

\subsection{Porównanie złożoności obliczeniowej}

Algorytm Dijkstry posiada złożoność czasową rzędu $O((V + E) \log V)$ przy zastosowaniu kolejki priorytetowej opartej na kopcu binarnym, gdzie $V$ oznacza liczbę wierzchołków, a $E$ liczbę krawędzi w grafie. W przypadku siatki dwuwymiarowej $N \times N$ mamy $V = N^2$ wierzchołków i $E \approx 4N^2$ krawędzi (każdy wierzchołek ma co najwyżej 4 sąsiadów), co daje złożoność $O(N^2 \log N)$.

Algorytm A* ma teoretycznie taką samą złożoność jak Dijkstra — $O((V + E) \log V)$ — jednak w praktyce jest szybszy dzięki funkcji heurystycznej. Heurystyka (w tym przypadku odległość euklidesowa) pozwala na inteligentniejsze przeszukiwanie grafu, kierując eksplorację w stronę celu. W najlepszym przypadku, gdy heurystyka jest dokładna, A* może odwiedzić znacznie mniej wierzchołków niż Dijkstra, co przekłada się na krótszy czas wykonania.

W efekcie, choć oba algorytmy mają podobną asymptotyczną złożoność, A* jest szybszy w praktyce dzięki zmniejszeniu liczby odwiedzanych wierzchołków. Dla badanej siatki $1000 \times 1000$ A* był o około 30\% szybszy od Dijkstry.

\include*{shortest_path_chart}


\section{Opis implementacji algorytmów}

\subsection{Algorytm Dijkstry}

Algorytm Dijkstry jest klasyczną metodą znajdowania najkrótszej ścieżki w grafie z nieujemnymi wagami krawędzi. W implementacji wykorzystano kolejkę priorytetową opartą na kopcu binarnym, która pozwala na efektywne wybieranie wierzchołka o najmniejszej aktualnej odległości od źródła.

Algorytm działa w następujący sposób:
\begin{enumerate}
    \item Inicjalizacja: wszystkie wierzchołki otrzymują odległość $\infty$, z wyjątkiem wierzchołka startowego, którego odległość wynosi 0.
    \item Dopóki kolejka priorytetowa nie jest pusta:
    \begin{itemize}
        \item Wybierz wierzchołek o najmniejszej odległości z kolejki.
        \item Jeśli wierzchołek został już odwiedzony, pomiń go.
        \item Oznacz wierzchołek jako odwiedzony.
        \item Jeśli osiągnięto cel, zwróć odległość i zakończ.
        \item Dla każdego sąsiada sprawdź, czy można poprawić jego odległość poprzez przejście przez aktualny wierzchołek. Jeśli tak, zaktualizuj odległość i dodaj sąsiada do kolejki.
    \end{itemize}
\end{enumerate}

\subsection{Algorytm A*}

Algorytm A* rozszerza metodę Dijkstry poprzez wprowadzenie funkcji heurystycznej $h(n)$, która szacuje odległość od wierzchołka $n$ do celu. W implementacji zastosowano odległość euklidesową jako heurystykę:
\[
h(n) = \sqrt{(x_n - x_{cel})^2 + (y_n - y_{cel})^2}
\]

Algorytm A* operuje na dwóch funkcjach:
\begin{itemize}
    \item $g(n)$ — rzeczywista odległość od startu do wierzchołka $n$
    \item $f(n) = g(n) + h(n)$ — szacowana całkowita odległość od startu przez $n$ do celu
\end{itemize}

Kluczową różnicą w stosunku do Dijkstry jest priorytetyzacja wierzchołków według wartości $f(n)$ zamiast samego $g(n)$. Dzięki temu algorytm A* kieruje przeszukiwanie w stronę celu, odwiedzając mniej wierzchołków niż Dijkstra.

\subsection{Reprezentacja problemu}

Problem został zaimplementowany jako siatka dwuwymiarowa, gdzie każde pole może być:
\begin{itemize}
    \item Polem wolnym (wartość 0) — koszt przejścia wynosi 1
    \item Ścianą/przeszkodą (wartość 1) — nie można przejść
    \item Punktem startowym (wartość 2)
    \item Punktem końcowym (wartość 3)
\end{itemize}

Z siatki budowany jest graf, w którym każde wolne pole ma co najwyżej 4 sąsiadów (góra, dół, lewo, prawo). Wszystkie krawędzie mają wagę 1, co odpowiada kosztowi przejścia między sąsiednimi polami.

\subsection{Generowanie instancji testowych}

Do eksperymentów wykorzystano losowo generowane instancje problemu. Każda instancja charakteryzuje się:
\begin{itemize}
    \item Rozmiarem siatki $N \times N$
    \item Losowym rozmieszczeniem przeszkód (30\% pól to ściany)
    \item Losowo wybranymi pozycjami startu i mety
\end{itemize}

Taki sposób generowania danych pozwala na symulację różnorodnych scenariuszy i zapewnia reprezentatywność wyników pomiarów.
\section{Podsumowanie}

W ramach przeprowadzonych badań przeanalizowano dwa algorytmy wyznaczania najkrótszej ścieżki w grafie dwuwymiarowym: algorytm Dijkstry oraz algorytm A*. Otrzymane wyniki potwierdziły przewagę algorytmu A* w zakresie wydajności obliczeniowej dla większych instancji problemu.

Algorytm Dijkstry, będący klasycznym rozwiązaniem problemu najkrótszej ścieżki, charakteryzuje się prostotą implementacji i gwarantuje znalezienie optymalnej trasy. Jest to solidny wybór, gdy nie dysponujemy dobrą funkcją heurystyczną lub gdy priorytetem jest prostota kodu.

Z kolei algorytm A*, wykorzystując funkcję heurystyczną (odległość euklidesowa do celu), kieruje przeszukiwaniem w stronę punktu docelowego, co prowadzi do zmniejszenia liczby odwiedzanych wierzchołków. W przeprowadzonych eksperymentach A* okazał się o około 30\% szybszy od Dijkstry dla siatek o rozmiarze $1000 \times 1000$, przy zachowaniu gwarancji znalezienia optymalnej ścieżki.

Pomiary czasowe wykazały, że dla małych instancji (do $300 \times 300$) różnica w wydajności jest niewielka, jednak staje się ona znacząca wraz ze wzrostem rozmiaru problemu. Oba algorytmy wykazują złożoność obliczeniową rzędu $O(N^2 \log N)$ dla siatki $N \times N$, jednak dzięki heurystyce A* odwiedza mniej wierzchołków w praktyce.

Podsumowując, wybór odpowiedniego algorytmu zależy od kontekstu zastosowania:
\begin{itemize}
    \item gdy priorytetem jest prostota implementacji i brak jest dobrej funkcji heurystycznej — algorytm Dijkstry jest właściwym wyborem,
    \item gdy dostępna jest sensowna heurystyka i istotna jest wydajność — algorytm A* zapewnia lepszą efektywność przy zachowaniu optymalności rozwiązania.
\end{itemize}

\end{document}